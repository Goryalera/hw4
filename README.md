# hw4

# Рекурсивное вычисление степени числа (power)

В этом репозитории представлены реализации функции возведения числа в степень рекурсивным методом на трёх языках: Python, Java и C++.вариант 2, вопрос 8

---

## Python

### Как работает алгоритм:
- `def power(x, n):` — объявление функции с параметрами `x` (число) и `n` (степень).
- `if n == 0:` — базовый случай, возвращает 1 (число в степени 0 равно 1).
- `elif n > 0:` — рекурсивный случай для положительной степени, возвращает `x * power(x, n - 1)`.
- `else:` — обработка отрицательной степени, возвращает обратное значение степени `-n`.

### Временная сложность:  
O(n)

### Почему такая сложность:  
Рекурсия вызывается n раз, уменьшая степень на 1 на каждом шаге.

---

## Java

### Как работает алгоритм:
- `public static double power(double x, int n)` — метод с параметрами `x` (число с плавающей точкой) и `n` (степень).
- `if (n == 0)` — базовый случай, возвращает 1.
- `else if (n > 0)` — рекурсивно умножает `x` на `power(x, n - 1)`.
- `else` — вычисляет обратную степень для отрицательных `n`.

### Временная сложность:  
O(n)

### Почему такая сложность:  
Функция рекурсивно вызывается n раз, уменьшая показатель степени на 1.

---

## C++

### Как работает алгоритм:
- `double power(double x, int n)` — объявление функции с параметрами `x` и `n`.
- `if (n == 0)` — базовый случай, возвращает 1.
- `else if (n > 0)` — возвращает `x`, умноженное на результат рекурсивного вызова с `n - 1`.
- `else` — возвращает обратное значение степени для отрицательных `n`.

### Временная сложность:  
O(n)

### Почему такая сложность:  
На каждом шаге уменьшается степень на 1, поэтому количество вызовов равно n.

###контрольный вопрос: Чем отличаются перестановки от сочетаний?
Перестановки и сочетания отличаются тем, что перестановки учитывают порядок элементов, а сочетания — нет. В контексте кода для функции вычисления степени числа это важное различие в понимании комбинаторики, хотя напрямую функции не связаны с перестановками или сочетаниями.

- Перестановка — это способ упорядочить элементы множества по-разному, при этом меняя их последовательность мы получаем разные перестановки (например, abc, bca, cab — разные перестановки).
- Сочетание — это выборка элементов из множества без учёта порядка, то есть наборы abc, bca и cab считаются одним и тем же сочетанием.

Таким образом, если задачу представить как выбор элементов для операций (например, умножений), перестановки учитывают разные последовательности, а сочетания — только набор выбранных элементов без порядка.

В коде рекурсивного возведения в степень порядок умножения важен, так что скорее это ближе к перестановкам (поскольку $$x \times power(x, n-1)$$ учитывает последовательность вызовов), хотя обычно операции умножения коммутативны и порядок не влияет на результат. 

Основное различие в теории:  
- перестановки работают с упорядоченными наборами,  
- сочетания с неупорядоченными.
